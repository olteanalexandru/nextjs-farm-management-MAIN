<details><summary> # example of interface / types / functions / enums / generics / namespaces / modules</summary>
    <p> 
    
    
    <h2 id="interface">interface</h2>
    <pre><code>interface SomePerson {
        name: string;
        age: number;
        greet(phrase: string): void;
    }
    
    let user1: SomePerson;
    
    user1 = {
        name: &#39;Max&#39;,
        age: 30,
        greet(phrase: string) {
            phrase = phrase + &#39; &#39; + this.name;
        }
    };
    </code></pre>
    <h2 id="type">type</h2>
    <pre><code>type AddFn = (a: number, b: number) =&gt; number;  // type alias for function type (function signature)  
    let add: AddFn;                                  
    add = (n1: number, n2: number) =&gt; {
        return n1 + n2;
    };
    </code></pre>
    <h2 id="simple-types">simple types</h2>
    <pre><code>let name2: string = &#39;Max&#39;;
    let age: number = 30;
    let hasHobbies: boolean = true;
    </code></pre>
    <h2 id="array-types">array types</h2>
    <pre><code>let hobbies: string[] = [&#39;Sports&#39;, &#39;Cooking&#39;];
    let hobbies2: any[] = [&#39;Sports&#39;, 1, true];
    </code></pre>
    <h2 id="tuples">tuples</h2>
    <pre><code>let address: [string, number] = [&#39;Superstreet&#39;, 99];
    </code></pre>
    <h2 id="enums">enums</h2>
    <pre><code>enum Color {
        Gray,   // 0
        Green,  // 1
        Blue    // 2
    }
    
    let myColor: Color = Color.Green;
    console.log(myColor);   // 1
    </code></pre>
    </p>
    </details>
    
    <details><summary> Classes </summary>
    <p> 
    
    <h1 id="classes">classes</h1>
    <pre><code>class Person {
        name: string;  // public
        private type: string;   // private 
        protected TheAge: number = 30; // protected
    
        constructor(name: string, public username: string) { // public username: string is a shortcut for this.username = username; 
            this.name = name;
        }
    
        printAge() {
            console.log(this.TheAge);
            this.setType(&#39;Old Guy&#39;); // can access private method
        }
    
        private setType(type: string) {
            this.type = type;
            console.log(this.type);
        }
    }
    
    const person = new Person(&#39;Max&#39;, &#39;max&#39;);
    console.log(person.name, person.username);
    </code></pre>
    <h2 id="inheritance">inheritance</h2>
    <pre><code>class Max extends Person {
        // name = &#39;Max&#39;; // override name property
        constructor(username: string) {
            super(&#39;Max&#39;, username);  // call parent constructor
            this.TheAge = 31;
        }
    }
    
    const max = new Max(&#39;max&#39;);
    console.log(max);
    </code></pre>
    <h2 id="getters--setters">getters &amp; setters</h2>
    <pre><code>class Plant {
        private _species: string = &#39;Default&#39;;
    
        get species() {
            return this._species;
        }
    
        set species(value: string) {
            if (value.length &gt; 3) {
                this._species = value;
            } else {
                this._species = &#39;Default&#39;;
            }
        }
    }
    
    let plant = new Plant();
    console.log(plant.species);
    
    plant.species = &#39;AB&#39;;
    console.log(plant.species);
    
    plant.species = &#39;Green Plant&#39;;
    console.log(plant.species);
    </code></pre>
    <h2 id="static-properties--methods">static properties &amp; methods</h2>
    <p> static properties &amp; methods are attached to the class itself, not to the instances of the class</p>
    <pre><code>class Helpers {
        static PI: number = 3.14;       
        static calcCircumference(diameter: number): number {
            return this.PI * diameter;
        }
    }
    
    console.log(2 * Helpers.PI);
    console.log(Helpers.calcCircumference(8));
    </code></pre>
    <h2 id="abstract-classes">abstract classes</h2>
    <p> abstract classes are base classes from which other classes may be derived. They may not be instantiated directly.
     abstract classes may contain implementation details for its members. The abstract keyword is used to define abstract classes as well as abstract methods within an abstract class.</p>
    <pre><code>abstract class Project {
        projectName: string = &#39;Default&#39;;
        budget: number = 1000;
    
        abstract changeName(name: string): void;
    
        calcBudget() {
            return this.budget * 2;
        }
    }
    
    class ITProject extends Project {
        changeName(name: string): void {
            this.projectName = name;
        }
    }
    
    let newProject = new ITProject();
    console.log(newProject);
    newProject.changeName(&#39;Super IT Project&#39;);
    console.log(newProject);
    </code></pre>
    <h2 id="private-constructors">private constructors</h2>
    <p> private constructors are used to prevent the class from being instantiated</p>
    <pre><code>class OnlyOne {
        private static instance: OnlyOne;
    
        private constructor(public name: string) {}
    
        static getInstance() {
            if (!OnlyOne.instance) {
                OnlyOne.instance = new OnlyOne(&#39;The Only One&#39;);
            }
            return OnlyOne.instance;
        }
    }
    
    // let wrong = new OnlyOne(&#39;The Only One&#39;); // error
    let right = OnlyOne.getInstance();
    console.log(right.name);
    // right.name = &#39;Something else&#39;; // error
    </code></pre>
    <h2 id="namespaces">namespaces</h2>
    <p> namespaces are used to organize code into logical groups and to provide a way to handle name collisions</p>
    <pre><code>namespace MyMath {
        const PI = 3.14;
    
        export function calcCircumference(diameter: number) {
            return diameter * PI;
        }
    
        export function calcRectangle(width: number, length: number) {
            return width * length;
        }
    }
    
    console.log(MyMath.calcCircumference(8));
    console.log(MyMath.calcRectangle(8, 20));
    </code></pre>
    <h2 id="modules--">modules -</h2>
    <p> modules are used to organize code into logical groups and to provide a way to handle name collisions
     modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms.  </p>
    <pre><code>// module.ts
    export class SomeClass {
        public someProperty: string = &#39;someProperty&#39;;
    }
    
    // app.ts
     import { SomeClass } from &#39;./module&#39;;
    
     let someClass = new SomeClass();
     console.log(someClass.someProperty);
    </code></pre>
    <h2 id="decorators--">decorators -</h2>
    <p> decorators are functions that can be attached to classes, methods, accessors, properties, or parameters. Decorators use the form @expression, where expression must evaluate to a function that will be called at runtime with information about the decorated declaration.
     decorators are a stage 2 proposal for JavaScript and are available as an experimental feature of TypeScript.
     decorators are a TypeScript feature that allow you to add both annotations and a meta-programming syntax for class declarations and members. Decorators are a stage 2 proposal for JavaScript and are available as an experimental feature of TypeScript.</p>
    <pre><code>let logged = function(target: any, propertyName: string | Symbol) {
       console.log(target);
       console.log(propertyName);
    }
    
    class Person {
       @logged
       name: string;
    
       constructor() {
           console.log(&#39;Hi!&#39;);
       }
    }
    </code></pre>
    <h2 id="factory">factory</h2>
    <pre><code>function logging(value: boolean) {
        return value ? logged : null;
    }
    
    class Car {
        
            @logging(true)
            name: string;
        
            constructor() {}
        }
    </code></pre>
    <h2 id="advanced">advanced</h2>
    <pre><code>function printable(constructorFn: Function) {
        constructorFn.prototype.print = function() {
            console.log(this);
        }
    }
    
    @printable
    class Plant {
        name = &#39;Green Plant&#39;;
    }
    
    const plant = new Plant();
    (&lt;any&gt;plant).print();
    </code></pre>
    <h2 id="method-decorator">method decorator</h2>
    <p> a method decorator is declared just before a method declaration. The method decorator is applied to the Property Descriptor for the method, and can be used to observe, modify, or replace a method definition.
     a method decorator cannot be used in a declaration file, or in any other ambient context (such as in the body of an ambient function expression).
     a method decorator is applied when the class containing the decorated method is declared. The decorator is called as a function at runtime, with the following three arguments:</p>
    <ol>
    <li>For a static member, the constructor function of the class. For an instance member, the prototype of the class.</li>
    <li>The name of the member.</li>
    <li>The Property Descriptor for the member.</li>
    </ol>
    <pre><code>function editable(value: boolean) {
        return function(target: any, propName: string, descriptor: PropertyDescriptor) {
            descriptor.writable = value;
        }
    }
    
    function overwritable(value: boolean) {
        return function(target: any, propName: string): any {
            const newDescriptor: PropertyDescriptor = {
                writable: value
            };
            return newDescriptor;
        }
    }
    
    class Project {
        @overwritable(false)
        projectName: string;
    
        constructor(name: string) {
            this.projectName = name;
        }
    
        @editable(false)
        calcBudget() {
            console.log(1000);
        }
    }
    
    const project = new Project(&#39;Super Project&#39;);
    project.calcBudget();
    project.calcBudget = function() {
        console.log(2000);
    }
    project.calcBudget();
    </code></pre>
    <h2 id="parameter-decorator">parameter decorator</h2>
    <p> a parameter decorator is declared just before a parameter declaration. A parameter decorator is applied to the constructor function of the class for a static member, or the prototype of the class for an instance member.
     a parameter decorator cannot be used in a declaration file, or in any other ambient context (such as in the body of an ambient function expression).</p>
    <pre><code>function printInfo(target: any, methodName: string, paramIndex: number) {
        console.log(&#39;Target: &#39;, target);
        console.log(&#39;methodName: &#39;, methodName);
        console.log(&#39;paramIndex: &#39;, paramIndex);
    }
    
    class Course {
        name: string;
    
        constructor(name: string) {
            this.name = name;
        }
    
        printStudentNumbers(mode: string, @printInfo printAll: boolean) {
            if (printAll) {
                console.log(10000);
            } else {
                console.log(2000);
            }
        }
    }
    
    const course = new Course(&#39;Super Course&#39;);
    course.printStudentNumbers(&#39;anything&#39;, true);
    </code></pre>
    </p>
    </details>
    
    <details><summary>  OOP - Object Oriented Programming core concepts brief overview</summary>
    <p>
    
    <h2 id="inheritance--">Inheritance -</h2>
    <p> is a mechanism in which one object acquires all the properties and behaviors of a parent object. It is an important part of object-oriented programming (OOP) in which one class acquires the properties (methods and fields) of another. With the use of inheritance the information is made manageable in a hierarchical order.</p>
    <h2 id="encapsulation--get--set--">encapsulation ( get / set) -</h2>
    <p> is the mechanism of wrapping the data (variables) and code acting on the data (methods) together as a single unit. In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class. Therefore, it is also known as data hiding.</p>
    <pre><code>
    class Person {
        private name: string;
        private type: string;
        private age: number = 27;
    
        constructor(name: string, public username: string) {
            this.name = name;
        }
    
        printAge() {
            console.log(this.age);
            this.setType(&quot;Old Guy&quot;);
        }
    
        private setType(type: string) {
            this.type = type;
            console.log(this.type);
        }
    }
    </code></pre>
    <h2 id="polymorphism--">PolyMorphism -</h2>
    <p> is the ability of a variable, function, or object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object.
     Polymorphism reffering to interfaces and abstract classes - is a design principle that allows a class to be defined by its behavior and not by its attributes. Polymorphism is achieved by using abstract classes and interfaces.
     Polymorphism reffering to inheritance - is a design principle that allows a class to be defined by its behavior and not by its attributes. Polymorphism is achieved by using inheritance.</p>
    <pre><code>class Car {
        protected name: string;
    
        constructor(name: string) {
            this.name = name;
        }
    
        printName() {
            console.log(this.name);
        }
    }
    </code></pre>
    <h2 id="abstraction--">Abstraction -</h2>
    <p> is the process of hiding the implementation details from the user, only the functionality will be provided to the user. In other words, the user will have the information on what the object does instead of how it does it.</p>
    <pre><code>
    class Car {
        protected name: string;
    
        constructor(name: string) {
            this.name = name;
        }
    
        printName() {
            console.log(this.name);
        }
    }
    </code></pre>
    <h1 id="interfaces--">Interfaces -</h1>
    <p> An interface is a syntactical contract that an entity should conform to. An interface defines the syntax that any entity must adhere to. Interfaces are used to achieve abstraction and also to support the concept of loose coupling in software design.
     Interfaces are similar to abstract classes. Both define abstract members that are implemented in derived classes. However, interfaces define only abstract members, whereas abstract classes can define both abstract and non-abstract members. In addition, interfaces cannot contain implementation for their members, whereas abstract classes can. Members of an interface are public by default.</p>
    <pre><code>
    interface NamedPerson {
        firstName: string;
        age?: number;
        [propName: string]: any;
        greet(lastName: string): void;
    }
    
    function greet(person: NamedPerson) {
        console.log(&quot;Hello, &quot; + person.firstName);
    }
    
    function changeName(person: NamedPerson) {
        person.firstName = &quot;Anna&quot;;
    }
    
    const person: NamedPerson = {
        firstName: &quot;Max&quot;,
        hobbies: [&quot;Cooking&quot;, &quot;Sports&quot;],
        greet(lastName: string) {
            console.log(&quot;Hi, I am &quot; + this.firstName + &quot; &quot; + lastName);
        }
    }
    
    greet(person);
    </code></pre>
    </p>
    </details>
    
    <details><summary> 
     SOLID</summary>
    <p>
    
    <p>SOLID is a set of principles for object-oriented design and programming.</p>
    <h1 id="s---single-responsibility-principle">S - Single responsibility principle</h1>
    <p> A class should have one and only one reason to change, meaning that a class should have only one job.</p>
    <h1 id="o---openclosed-principle">O - Open/closed principle</h1>
    <p> Objects or entities should be open for extension, but closed for modification.</p>
    <h1 id="l---liskov-substitution-principle">L - Liskov substitution principle</h1>
    <p> This principle states that &quot;objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.&quot;</p>
    <h1 id="i---interface-segregation-principle">I - Interface segregation principle</h1>
    <p> This principle states that &quot;many client-specific interfaces are better than one general-purpose interface.&quot;</p>
    <h1 id="d---dependency-inversion-principle">D - Dependency inversion principle</h1>
    <p> This principle states that &quot;one should &quot;depend upon abstractions, [not] concretions.&quot;</p>
    <h2 id="single-responsibility-principle">Single responsibility principle</h2>
    <pre><code>class User {
      constructor(name, email) {
        this.name = name;
        this.email = email;
      }
    
      changeEmail(newEmail) {
        this.email = newEmail;
      }
    }
    </code></pre>
    <h1 id="openclosed-principle">Open/closed principle</h1>
    <pre><code>class Shape {
      constructor(type) {
        this.type = type;
      }
    }
    
    class Circle extends Shape {
      constructor() {
        super(&#39;circle&#39;);
      }
    }
    
    class Square extends Shape {
      constructor() {
        super(&#39;square&#39;);
      }
    }
    
    class AreaCalculator {
      constructor(shapes = []) {
        this.shapes = shapes;
      }
    
      sum() {
        return this.shapes.reduce((acc, shape) =&gt; {
          if (shape.type === &#39;circle&#39;) {
            acc += (shape.radius ** 2) * Math.PI;
          }
    
          if (shape.type === &#39;square&#39;) {
            acc += shape.side ** 2;
          }
    
          return acc;
        }, 0);
      }
    }
    
    const calc = new AreaCalculator([
      new Circle(2),
      new Square(5),
      new Square(6),
    ]);
    
    console.log(calc.sum()); // 113.09733552923255
    </code></pre>
    <h2 id="liskov-substitution-principle">Liskov substitution principle</h2>
    <pre><code>class Person {
      constructor(name) {
        this.name = name;
      }
    
      walk() {
        return `${this.name} is walking`;
      }
    }
    
    class Employee extends Person {
      constructor(name, title) {
        super(name);
        this.title = title;
      }
    
      walk() {
        return `${this.name}, ${this.title}, is walking`;
      }
    }
    
    const p = new Person(&#39;John&#39;);
    
    console.log(p.walk()); // John is walking
    
    </code></pre>
    <h1 id="interface-segregation-principle">Interface segregation principle</h1>
    <pre><code>class Animal {
      constructor(name) {
        this.name = name;
      }
    
      eat() {
        return `${this.name} is eating`;
      }
    
      sleep() {
        return `${this.name} is sleeping`;
      }
    }
    
    </code></pre>
    <h1 id="dependency-inversion-principle">Dependency inversion principle</h1>
    <pre><code>class Fetch {
      request(url) {
        // return fetch(url).then(r =&gt; r.json());
      }
    }
    
    class LocalStorage {
      get() {
        const dataFromLocalStorage = &#39;data from local storage&#39;;
    
        return dataFromLocalStorage;
      }
    }
    
    class FetchClient {
    
      constructor() {
        this.fetch = new Fetch();
      }
    
      clientGet() {
        return this.fetch.request(&#39;vk.com&#39;);
      }
    }
    
    class LocalStorageClient {
    
      constructor() {
        this.localStorage = new LocalStorage();
      }
    
      clientGet() {
        return this.localStorage.get();
      }
    }
    
    class Database {
    
      constructor(client) {
        this.client = client;
      }
    
      getData(key) {
        return this.client.clientGet(key);
      }
    }
    
    const db = new Database(new FetchClient());
    
    console.log(db.getData(&#39;rand&#39;)); // data from fetch
    
    const db2 = new Database(new LocalStorageClient());
    
    console.log(db2.getData(&#39;rand&#39;)); // data from local storage
    </code></pre>
    </p>
    </details>
    
    <details><summary> 
     GRASP - General Responsibility Assignment Software Patterns</summary>
    <p>
    
    <p> GRASP oop concepts:
            -G -  Generalization 
            -R -  Reusability
            -A -  Abstraction
            -S -  Specialization
            -P -  Polymorphism</p>
    <h2 id="creator--">Creator -</h2>
    <p> is a class that creates other objects. It is responsible for knowing which classes need to be instantiated. It is also responsible for knowing how the instances of these classes will be created and used.</p>
    <pre><code>
    class Person {
        private name: string;
        private age: number;
    
        constructor(name: string, age: number) {
            this.name = name;
            this.age = age;
        }
    }
    
    class PersonFactory {
        static createPerson(name: string, age: number) {
            return new Person(name, age);
        }
    }
    
    const person = PersonFactory.createPerson(&#39;Max&#39;, 27);
    </code></pre>
    <h2 id="controller--">Controller -</h2>
    <p>is a class that controls the flow of data between the view and the model. It is responsible for knowing which data needs to be displayed and when. It is also responsible for knowing which model objects need to be updated and when.</p>
    <pre><code>class Person {
        private name: string;
        private age: number;
    
        constructor(name: string, age: number) {
            this.name = name;
            this.age = age;
        }
    }
    
    class PersonFactory {
        static createPerson(name: string, age: number) {
            return new Person(name, age);
        }
    }
    
    class PersonController {
        private persons: Person[] = [];
    
        addPerson(name: string, age: number) {
            const person = PersonFactory.createPerson(name, age);
            this.persons.push(person);
        }
    }
    
    const personController = new PersonController();
    
    personController.addPerson(&#39;Max&#39;, 27);
    </code></pre>
    <h2 id="high-cohesion--">High Cohesion -</h2>
    <p>is a measure of how strongly related the responsibilities of a class are. A class with high cohesion is focused on a single responsibility and has a small number of instance variables. A class with low cohesion has many responsibilities and many instance variables.</p>
    <pre><code>class Person {
        private name: string;
        private age: number;
    
        constructor(name: string, age: number) {
            this.name = name;
            this.age = age;
        }
    }
    
    class PersonFactory {
        static createPerson(name: string, age: number) {
            return new Person(name, age);
        }
    }
    
    class PersonController {
        private persons: Person[] = [];
    
        addPerson(name: string, age: number) {
            const person = PersonFactory.createPerson(name, age);
            this.persons.push(person);
        }
    }
    
    const personController = new PersonController();
    
    personController.addPerson(&#39;Max&#39;, 27);
    </code></pre>
    <h2 id="low-coupling--">Low Coupling -</h2>
    <p> is a measure of how dependent one class is on another. A class with low coupling depends on as few other classes as possible. A class with high coupling depends on many other classes.</p>
    <pre><code>class Person {
        private name: string;
        private age: number;
    
        constructor(name: string, age: number) {
            this.name = name;
            this.age = age;
        }
    }
    
    class PersonFactory {
        static createPerson(name: string, age: number) {
            return new Person(name, age);
        }
    }
    
    class PersonController {
        private persons: Person[] = [];
    
        addPerson(name: string, age: number) {
            const person = PersonFactory.createPerson(name, age);
            this.persons.push(person);
        }
    }
    
    const personController = new PersonController();
    
    personController.addPerson(&#39;Max&#39;, 27);
    </code></pre>
    <h2 id="inversion-of-control--">Inversion of Control -</h2>
    <p> is a design principle that allows the control flow of a program to be inverted. Inversion of control is achieved by using a framework that takes control of the flow of a program and delegates the execution of tasks to other objects.</p>
    <pre><code>
    class Car {
        drive() {
            console.log(&#39;Driving...&#39;);
        }
    }
    
    class CarFactory {
        static createCar() {
            return new Car();
        }
    }
    
    class CarController {
        private car: Car;
    
        constructor() {
            this.car = CarFactory.createCar();
        }
    
        drive() {
            this.car.drive();
        }
    }
    
    const carController = new CarController();
    
    carController.drive();
    </code></pre>
    <h2 id="dependency-injection--">Dependency Injection -</h2>
    <p> is a design pattern that allows the removal of hard-coded dependencies and makes it possible to change them, whether at runtime or compile time.</p>
    <pre><code>class cat {
        meow() {
            console.log(&#39;Meow!&#39;);
        }
    }
    
    class CatFactory {
        static createCat() {
            return new Cat();
        }
    }
    
    class CatController {
        private cat: Cat;
    
        constructor(cat: Cat) {
            this.cat = cat;
        }
    
        meow() {
            this.cat.meow();
        }
    }
    
    const cat = CatFactory.createCat();
    const catController = new CatController(cat);
    
    catController.meow();
    </code></pre>
    </p>
    </details>
    
    
    
    <details><summary> Functional Programing / Async - await</summary>
    <p>
    
    <h2 id="destructuring">destructuring</h2>
    <pre><code>let array = [1, 2, 3, 4, 5];
    
    let [a, b, c, d, e] = array;  // a = 1, b = 2, c = 3, d = 4, e = 5
    </code></pre>
    <h2 id="spread-operator">spread operator</h2>
    <pre><code>let array = [1, 2, 3, 4, 5];  
    
    let array2 = [...array, 6, 7, 8, 9, 10];  // array2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    </code></pre>
    <h2 id="rest-operator">rest operator</h2>
    <pre><code>function sum(...args: number[]): number {
        let sum = 0;
        for (let arg of args) {
            sum += arg;
        }
        return sum;
        }
    </code></pre>
    <h2 id="default-parameters">default parameters</h2>
    <pre><code>function sum(a: number, b: number = 0): number {
        return a + b  ;
        }
    </code></pre>
    <h2 id="arrow-functions">arrow functions</h2>
    <pre><code>let sum = (a: number, b: number): number =&gt; a + b;
    </code></pre>
    <h1 id="map--filter--reduce--sort--foreach--split--join--slice--splice--tostring">map / filter / reduce / sort / forEach / split / join / slice / splice / toString</h1>
    <h1 id="map">map</h1>
    <p>map creates a new array with the results of calling a provided function on every element in the calling array.</p>
    <pre><code>let array = [1, 2, 3, 4, 5];
    let items = {
        name: &#39;alex&#39;,price: 10,
        name: &#39;alex2&#39;,price: 20,
        name: &#39;alex3&#39;,price: 30,
    }
    </code></pre>
    <pre><code>let array2 = array.map((value) =&gt; value * 2); 
    let items2 = items.map((value) =&gt; value.price * 2);
    </code></pre>
    <h1 id="filter">filter</h1>
    <p>filter creates a new array with all elements that pass the test implemented by the provided function.</p>
    <pre><code>let array2 = array.filter((value) =&gt; value &gt; 3);
    let items2 = items.filter((value) =&gt; value.price &gt; 10);
    </code></pre>
    <h1 id="reduce">reduce</h1>
    <p>reduce applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.</p>
    <pre><code>let array2 = array.reduce((accumulator, currentValue) =&gt; accumulator + currentValue);
    let items2 = items.reduce((accumulator, currentValue) =&gt; accumulator + currentValue.price);
    </code></pre>
    <h1 id="sort">sort</h1>
    <p>sort sorts the elements of an array in place and returns the sorted array.</p>
    <pre><code>let array2 = array.sort((a, b) =&gt; a - b);
    let items2 = items.sort((a, b) =&gt; a.price - b.price); //sort by price
    </code></pre>
    <h1 id="foreach">forEach</h1>
    <p>forEach executes a provided function once for each array element.</p>
    <pre><code>array.forEach((value) =&gt; console.log(value));
    </code></pre>
    <h1 id="split">split</h1>
    <p>split splits a String object into an array of strings by separating the string into substrings.</p>
    <pre><code>let string = &#39;12345&#39;;
    
    let array = string.split(&#39;&#39;);
    </code></pre>
    <h1 id="join">join</h1>
    <p>join joins all elements of an array into a string.</p>
    <pre><code>let string = array.join(&#39;&#39;);
    </code></pre>
    <h1 id="slice">slice</h1>
    <p>slice extracts a section of a string and returns it as a new string, without modifying the original string.</p>
    <pre><code>let string2 = string.slice(2);
    </code></pre>
    <h1 id="splice">splice</h1>
    <p>splice changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.</p>
    <pre><code>let array2 = array.splice(2, 1);
    </code></pre>
    <p>toString
    toString returns a string representing the specified array and its elements.</p>
    <pre><code>let string = array.toString();
    </code></pre>
    <h1 id="async--await">async / await</h1>
    <p>async / await is a way to write asynchronous code that looks synchronous.
    async / await is built on top of promises.
    asyncronous code is code that is not executed in order and is executed at a later time.
    it is superior to synchronous code because it does not block the execution of other code.</p>
    <pre><code>
    let asyncFunc = async () =&gt; {
        try {
            let MapFilter = await MapFilter();
            return MapFilter;
        } catch (error) {
            console.log(error);
        }
        }
    
    let MapFilter = () =&gt; {
        let array = [1, 2, 3, 4, 5];
        let array2 = array.map((value) =&gt; value * 2).filter((value) =&gt; value &gt; 3);
        return array2;
        }
    
    asyncFunc().then((result) =&gt; console.log(result));
    </code></pre>
    </p>
    </details>
    
    
    
    
    
    
    
    
    <details><summary> 
     Functional programing concepts</summary>
    <p>
     1. Pure functions ,
     2. Immutability
     3. First class functions
     4. Higher order functio
     5. Currying
     6. Composition
     7. Point free style
     8. Lazy evaluation
     9. Recursion
     10. Referential transparency
     11. Algebraic data types
     12. Pattern matching
     13. Type classes
     14. Monads
     15. Functors
     16. Applicatives
     17. Monoids
    
    
    <h1 id="1-pure-functions">1. Pure functions</h1>
    <p> A pure function is a function that has no side effects and always returns the same result given the same arguments.
     Pure functions are idempotent, meaning that they can be called multiple times with the same arguments without changing the result or state of the program.
     Pure functions are also referentially transparent, meaning that they can be replaced with their return value without changing the behavior of the program.
     Pure functions are easier to test, compose, and reason about than impure functions.</p>
    <h1 id="2-immutability">2. Immutability</h1>
    <p> Immutability is a state in which an object cannot be modified after it is created.
     Immutability is a core concept in functional programming.
     Immutability makes it easier to reason about your code because you know that an object will never change.
     Immutability also makes it easier to test your code because you don&#39;t have to worry about the state of an object changing during a test.
     Immutability is also a performance optimization because it allows JavaScript engines to make certain assumptions about your code that they would not be able to make if your code were mutable.</p>
    <h1 id="3-first-class-functions">3. First class functions</h1>
    <p> A first class function is a function that can be assigned to a variable, passed as an argument to another function, or returned from another function.
     First class functions are a core concept in functional programming.
     First class functions allow you to abstract over actions, not just values.
     First class functions allow you to treat functions as values and pass functions as arguments to other functions, which is called higher order functions.</p>
    <h1 id="4-higher-order-functions">4. Higher order functions</h1>
    <p> A higher order function is a function that takes a function as an argument, returns a function, or both.
     Higher order functions are a core concept in functional programming.
     Higher order functions allow you to abstract over actions, not just values.
     Higher order functions allow you to treat functions as values and pass functions as arguments to other functions, which is called higher order functions.</p>
    <h1 id="5-currying">5. Currying</h1>
    <p> Currying is the process of transforming a function that takes multiple arguments into a function that takes them one at a time.
     Currying is a core concept in functional programming.
     Currying is useful for partial application.
     Currying is useful for creating reusable, composable functions.</p>
    <h1 id="6-composition">6. Composition</h1>
    <p> Composition is the process of combining two or more functions to produce a new function.
     Composition is a core concept in functional programming.
     Composition is useful for creating reusable, composable functions.</p>
    <pre><code>const compose = (f, g) =&gt; x =&gt; f(g(x));
    const toUpperCase = x =&gt; x.toUpperCase();
    const exclaim = x =&gt; x + &#39;!&#39;;
    const shout = compose(exclaim, toUpperCase);
    shout(&#39;send in the clowns&#39;);
    </code></pre>
    <h1 id="7-point-free-style">7. Point free style</h1>
    <p> Point free style is the process of composing functions without explicitly mentioning the arguments to the composed functions.
     Point free style is a core concept in functional programming.
     Point free style is useful for creating reusable, composable functions.</p>
    <h1 id="8-lazy-evaluation">8. Lazy evaluation</h1>
    <p> Lazy evaluation is the process of deferring the evaluation of an expression until its value is needed.
     Lazy evaluation is a core concept in functional programming.
     Lazy evaluation is useful for creating reusable, composable functions.</p>
    <pre><code>const repeat = (str, times) =&gt; {
      let result = &#39;&#39;;
      for (let i = 0; i &lt; times; i++) {
        result += str;
      }
      return result;
    }
    </code></pre>
    <h1 id="9-recursion">9. Recursion</h1>
    <p> Recursion is the process of defining something in terms of itself.
     Recursion is a core concept in functional programming.
     Recursion is useful for creating reusable, composable functions.</p>
    <pre><code>const repeat2 = (str, times, result = &#39;&#39;) =&gt; {
        if (times &lt;= 0) {
            return result;
        }
        return repeat(str, times - 1, result + str);
        }
    
    const repeat3 = (str, times) =&gt; times &lt;= 0 ? &#39;&#39; : repeat(str, times - 1, str + str);
    </code></pre>
    <h1 id="10-referential-transparency">10. Referential transparency</h1>
    <p> Referential transparency is the property of an expression that can be replaced with its value without changing the behavior of the program.</p>
    <h1 id="11-algebraic-data-types">11. Algebraic data types</h1>
    <p> An algebraic data type is a type that is defined by its values.
     Algebraic data types are a core concept in functional programming.</p>
    <h1 id="12-pattern-matching">12. Pattern matching</h1>
    <p> Pattern matching is the process of checking a value against a pattern.</p>
    <h1 id="13-type-classes">13. Type classes</h1>
    <p> A type class is a set of types that share certain common behaviors.</p>
    <h1 id="14-monads">14. Monads</h1>
    <p> A monad is a type that implements the monad interface by providing a flatMap method.</p>
    <h1 id="15-functors">15. Functors</h1>
    <p> A functor is a type that implements the functor interface by providing a map method.</p>
    <h1 id="16-applicatives">16. Applicatives</h1>
    <p> An applicative is a type that implements the applicative interface by providing an ap method.</p>
    <h1 id="17-monoids">17. Monoids</h1>
    <p> A monoid is a type that implements the monoid interface by providing an empty method and a concat method.</p>
    <h1 id="call-by-reference">call by reference</h1>
    <p> means that the object is passed by reference, not by value.
     The reference is passed to the function, so if the function changes the object&#39;s properties, that change is visible outside the function, as shown in the following example:</p>
    <pre><code>const one = {
     name: &#39;one&#39;,
    }
    
    const two = one;
    
    two.name = &#39;two&#39;;
    
    console.log(one.name); // two
    </code></pre>
    <h1 id="call-by-value">call by value</h1>
    <p> means that the object is passed by value, not by reference.
     The value is passed to the function, so if the function changes the object&#39;s properties, that change is not visible outside the function, as shown in the following example:</p>
    <pre><code>const one2 = {
      name: &#39;one&#39;,
    }
    
    const two2 = {
      ...one2,     
    };
    
    two2.name = &#39;two&#39;;
    
    console.log(one2.name); // one
    </code></pre>
    <h2 id="map--filter--reduce-prototype-methods">map / filter / reduce prototype methods</h2>
    <h1 id="map-1">map</h1>
    <pre><code>let myMap = [1, 2, 3, 4, 5].map((item) =&gt; {
      return item * 2;
    }
    
    Array.prototype.myMap  = function (callback ) {
      let result = [];
      for (let i = 0; i &lt; this.length; i++) {
        result.push(callback(this[i], i, this));  // callback(item, index, array)
      }
      return result ;
    }
    </code></pre>
    <p>#filter</p>
    <pre><code>let myFilter = [1, 2, 3, 4, 5].filter((item) =&gt; {
      return item &gt; 2;
    }
    
    Array.prototype.myFilter = function (callback) {
      let result = [];
      for (let i = 0; i &lt; this.length; i++) {
        if (callback(this[i], i, this)) {  // callback(item, index, array)
          result.push(this[i]);
        }
    </code></pre>
    <p>#reduce</p>
    <pre><code>let myReduce = [1, 2, 3, 4, 5].reduce((acc, item) =&gt; {
      return acc + item;
    }
    
    Array.prototype.myReduce = function (callback, initialValue) {
      let acc = initialValue;
      let i = 0;
      if (initialValue === undefined) {
        acc = this[0];
        i = 1;
      }
      for (i; i &lt; this.length; i++) {
        acc = callback(acc, this[i], i, this);  // callback(acc, item, index, array)
      }
      return acc;
    }
    </code></pre>
    </p>
    </details>
    
    
    <details><summary> 
    OOP - Func   Mixin pattern
    </summary>
    
    
    
    <h2 id="mixin-pattern">Mixin pattern</h2>
    <ol>
    <li>Mixin Classes
    Two mixin classes are defined:</li>
    </ol>
    <p>CanSayHi: A class that provides a sayHi method.
    HasSuperPower: A class that provides a superpower method.</p>
    <pre><code>class CanSayHi {
    name ;
    sayHi() {
       return `Hi, I am ${this.name}`;
    }
    }
    
    class HasSuperPower {
    heroName ;
    
    superpower() {
       return `${this.heroName} can fly`;
    }
    
    }
    </code></pre>
    <ol start="2">
    <li>Target Class
    The superHero class is the target class that will incorporate the mixins. It implements both CanSayHi and HasSuperPower.</li>
    </ol>
    <pre><code>
    class superHero implements CanSayHi, HasSuperPower {
    heroName 
    
    constructor(public name: string) {
       this.heroName = name;
    }
    
    sayHi: () =&gt; string;
    superpower: () =&gt; string;
    
    }
    </code></pre>
    <ol start="3">
    <li>Applying Mixins
    The applyMixins function is defined to apply mixins to the target class. It copies the methods from mixin classes to the target class prototype.</li>
    </ol>
    <pre><code>
    
    
    function applyMixins(derivedCtor: any, baseCtors: any[]) {
    baseCtors.forEach(baseCtor =&gt; {
      Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {
          derivedCtor.prototype[name] = baseCtor.prototype[name];
      });
    });
    }
    </code></pre>
    <ol start="4">
    <li>Usage
    Mixins are applied to the superHero class using applyMixins. An instance of superHero is then created, and both mixin methods are called.</li>
    </ol>
    <pre><code>
     applyMixins(superHero, [CanSayHi, HasSuperPower]);
    
    let hero = new superHero(&#39;Superman&#39;);
    
    console.log(hero.sayHi());
    console.log(hero.superpower());
    </code></pre>
    </p>
    </details>
    
    
    